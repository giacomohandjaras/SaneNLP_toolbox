function [counts,words,total_words, unique_words, unique_ranks, max_rank,min_rank,ranks]=SNLP_getOccurrence(dictionary_file,words_of_interest)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%Open a dictionary file generated by Word2Vec and considering a set of words of interest, returns a set of measures (e.g., words frequency, ranking...)
%%%%
%%%%Usage:
%%%%	[counts,words,total_words, unique_words, unique_ranks, max_rank,min_rank,ranks]=SNLP_getOccurrence(dictionary_file,words_of_interest)
%%%%
%%%%	dictionary_file: an UTF-8 TXT dictionary file generated by Word2Vec (option -save-vocab, and with -min-count 1)
%%%%	words_of_interest: a cell array (N x 1), representing a set of words to be used to measure frequency, ranking, etc. If a word ends with '*' (e.g., as in LIWC), all the words with the same root will be processed
%%%%
%%%%	counts: an array (N x 1) containing the raw occurrences of the words of interest
%%%%	words: a cell (N x 1) containing all the words in the dictionary file associated with the word of interest. This is not trivial if the word of interest ends with '*'
%%%%	total_words: an integer representing the sum of occurrences in the dictionary_file
%%%%	unique_words: an integer representing the amount of words included in the dictionary_file
%%%%	unique_ranks: an integer representing the number of ranks included in the dictionary_file, that is often lower than unique_words due to ties
%%%%	max_rank: the rank of the less frequent word
%%%%	min_rank: the rank of the most frequent word (in general should be 1)
%%%%	ranks: an array (N x 1) containing the ranks of each word
%%%%
%%%%
%%%%	Sane Natural Language Processing Toolkit, v0.01. https://github.com/giacomohandjaras/SaneNLP_toolbox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

counts=[];
words=[];
total_words=[];
unique_words=[];
unique_ranks=[];
max_rank=[];
min_rank=[];
ranks=[];

dictionary=SNLP_loadWords(dictionary_file);
dictionary(1)=[]; %%%removing initial </s>
dictionary=split(dictionary,' ');

dictionary_counts=cellfun(@str2num, dictionary(1:end,2)); %%%the second column contains the raw occurrences
dictionary=dictionary(:,1); %%%the first column contains the words

unique_words=numel(dictionary);
total_words=sum(dictionary_counts);

counts=zeros(numel(words_of_interest),1);
words=cell(numel(words_of_interest),1);
ranks=nan(numel(words_of_interest),1);

rank_fixed=(tiedrank(dictionary_counts*-1));  %%%the idea is to create ranks in a reverse order: rank #1 will be assigned to the most frequent word
unique_ranks=numel(unique(rank_fixed));
max_rank=max(rank_fixed);
min_rank=min(rank_fixed);

for w=1:numel(words_of_interest)
    pos=regexp(words_of_interest{w},"\*");
    if pos>0 %%%the word is a "stemmed" word
        [word]=strsplit(words_of_interest{w},'*');
        word_search=strcat('^',word(1,1),' *');
        word_mask=regexp(dictionary,word_search);
        word_mask_notempty = ~cellfun(@isempty, word_mask);
        word_found=dictionary(find(word_mask_notempty));
        words{w}=word_found;
        word_freq=dictionary_counts(find(word_mask_notempty));
        counts(w)=sum(word_freq);
        temp_ranks=find(word_mask_notempty);
        if(numel(temp_ranks)>0)
            ranks(w)=(rank_fixed(temp_ranks(1)));
        end
    else %%%the word is a "normal" word
        word_search=words_of_interest{w};
        word_mask=strcmp(dictionary,word_search);
        word_found=dictionary(find(word_mask));
        words{w}=word_found;
        word_freq=dictionary_counts(find(word_mask));
        counts(w)=sum(word_freq);
        temp_ranks=find(word_mask);
        if(numel(temp_ranks)>0)
            ranks(w)=(rank_fixed(temp_ranks(1)));
        end
    end
end

end



